name: Build OpenWrt (MX4200 v1 & v2)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */2 * * *'   # every 2 hours

jobs:
  check-upstream:
    runs-on: ubuntu-22.04
    outputs:
      latest: ${{ steps.get.outputs.latest }}
      changed: ${{ steps.compare.outputs.changed }}
    name: Check for upstream changes

    steps:
      - name: Get latest upstream commit
        id: get
        run: |
          git clone --depth 1 https://github.com/qosmio/openwrt-ipq.git upstream
          cd upstream
          LATEST=$(git rev-parse HEAD)
          echo "latest=$LATEST" >> "$GITHUB_OUTPUT"

      - name: Restore last upstream commit cache
        uses: actions/cache@v4
        with:
          path: .last_upstream_commit
          key: upstream-commit-${{ steps.get.outputs.latest }}
          restore-keys: |
            upstream-commit-

      - name: Compare with last build
        id: compare
        run: |
          LATEST="${{ steps.get.outputs.latest }}"
          if [ -f .last_upstream_commit ]; then
            LAST=$(cat .last_upstream_commit)
            if [ "$LAST" = "$LATEST" ]; then
              echo "No new commits ($LAST)."
              echo "changed=false" >> "$GITHUB_OUTPUT"
            else
              echo "New commit: $LATEST (was $LAST)."
              echo "changed=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "First run (no previous commit)."
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi
          # Update the marker so the cache can save it in post-step
          echo "$LATEST" > .last_upstream_commit

  build:
    needs: check-upstream
    if: needs.check-upstream.outputs.changed == 'true'
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        device: [mx4200v1, mx4200v2]
    name: Build OpenWrt ${{ matrix.device }}

    steps:
    - name: Checkout workflow repo
      uses: actions/checkout@v3

    - name: Set up build environment
      run: |
        sudo apt update
        sudo apt install -y \
          build-essential \
          gcc g++ gcc-multilib g++-multilib \
          flex bison clang gawk gettext git \
          libncurses-dev libssl-dev python3-distutils \
          rsync unzip zlib1g-dev file libelf-dev libc6-dev \
          libtool autoconf automake cmake pkg-config libglib2.0-dev
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        echo "LD=ld" >> $GITHUB_ENV

    - name: Checkout OpenWrt buildroot
      uses: actions/checkout@v4
      with:
        repository: qosmio/openwrt-ipq
        path: openwrt
        fetch-depth: 0   # full history, keeps proper rXXXXX version

    - name: Apply custom config and files
      run: |
        cd openwrt

        # Use custom feeds.conf if available
        cp ../feeds.conf.custom feeds.conf.default

        cd package

        # Clone custom packages
        git clone https://github.com/gSpotx2f/luci-app-interfaces-statistics.git
        git clone https://github.com/jerrykuku/luci-theme-argon.git
        git clone https://github.com/jerrykuku/luci-app-argon-config.git
        git clone https://github.com/gSpotx2f/luci-app-cpu-status.git

        cd ..

        ./scripts/feeds update -a
        ./scripts/feeds install -a

        # Add custom files if available
        if [ -d ../custom/files ]; then
          cp -a ../custom/files/. files/
          # Make all shebang-aware files executable
          find files/ -type f \
            -exec sh -c 'head -n1 "$1" | grep -q "^#!" && chmod +x "$1"' _ {} \;
        fi

        # Apply patches if any
        if [ -d ../custom/patches ]; then
          for patch in ../custom/patches/*.patch; do
            [ -f "$patch" ] && patch -p1 < "$patch"
          done
        fi

        # Use the right config.seed for the current matrix device
        cp ../config.${{ matrix.device }}.seed .config

    - name: Build firmware
      run: |
        cd openwrt
        make defconfig
        make download -j$(nproc)
        make -j$(nproc)

    - name: Upload firmware to Cloudflare R2
      id: upload-firmware
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_BUCKET: openwrt
        R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
      run: |
        cd openwrt/bin/targets
        TARGET_DIR=$(find . -type f -name version.buildinfo -exec dirname {} \;)
        cd "$TARGET_DIR"
        VERSION=$(cat version.buildinfo | tr -d '\n')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "Uploaded version $VERSION for ${{ matrix.device }}"

        sync
        sha256sum -c sha256sums

        for file in openwrt-qualcommax-ipq807x-linksys_${{ matrix.device }}*; do
          if [[ -f "$file" ]]; then
            if [[ "$file" == *.manifest ]]; then
              newfile="manifest"
            else
              newfile="${file#openwrt-qualcommax-ipq807x-linksys_${{ matrix.device }}-}"
            fi
            mv "$file" "$newfile"
          fi
        done

        aws --endpoint-url "$R2_ENDPOINT" s3 cp . "s3://$R2_BUCKET/${{ matrix.device }}/$VERSION/" --recursive --exclude "packages/*"

    - name: Emit result JSON (always)
      if: always()
      env:
        R2_URL: ow.okie.eu
        R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
        RUN_URL: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
      run: |
        DEVICE="${{ matrix.device }}"
        STATUS="${{ job.status }}"
        VERSION="${VERSION:-unknown}"

        if [ "$STATUS" = "success" ] && [ "$VERSION" != "unknown" ]; then
          URL="https://${R2_URL}/${DEVICE}/${VERSION}/squashfs-sysupgrade.bin"
        else
          URL="$RUN_URL"
        fi

        cat > result-${DEVICE}.json <<EOF
        {
          "device": "${DEVICE}",
          "status": "${STATUS}",
          "version": "${VERSION}",
          "url": "${URL}"
        }
        EOF

    - name: Upload result JSON artifact (always)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.device }}
        path: result-${{ matrix.device }}.json
        if-no-files-found: error

  notify:
    needs: [check-upstream, build]
    if: needs.check-upstream.outputs.changed == 'true'
    runs-on: ubuntu-22.04
    name: Send build result notification to Discord

    steps:
      - name: Download result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          merge-multiple: true
          path: results

      - name: Build Discord message
        id: msg
        run: |
          set -e
          summary=""
          ok=true

          for f in results/result-*.json; do
            device=$(jq -r '.device' "$f")
            status=$(jq -r '.status' "$f")
            version=$(jq -r '.version' "$f")
            url=$(jq -r '.url' "$f")

            if [ "$status" = "success" ]; then
              summary="$summary\nðŸŸ¢ **$device** built successfully (version: $version)\nðŸ’¾ **sysupgrade image:**\n<$url>"
            else
              summary="$summary\nðŸ”´ **$device** failed to build â†’ [View Logs]($url)"
              ok=false
            fi
          done

          if $ok; then
            title="# âœ… OpenWrt build succeeded!"
          else
            title="# âŒ OpenWrt build failed!"
          fi

          content="$title\n$summary"
          content="${content//'%'/%25}"
          content="${content//$'\n'/%0A}"
          content="${content//$'\r'/%0D}"

          echo "content=$content" >> $GITHUB_OUTPUT

      - name: Send Discord message
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          CONTENT: ${{ steps.msg.outputs.content }}
        run: |
          curl -H "Content-Type: application/json" -X POST \
               -d "{\"content\": \"$CONTENT\"}" \
               "$DISCORD_WEBHOOK_URL"
