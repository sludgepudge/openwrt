name: Build OpenWrt (MX4200 v1 & v2)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 21 * * *'

jobs:
  build:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        device: [mx4200v1, mx4200v2]
    name: Build OpenWrt ${{ matrix.device }}

    outputs:
      version: ${{ steps.upload-firmware.outputs.version }}
      device: ${{ matrix.device }}
      result: ${{ job.status }}

    steps:
    - name: Checkout workflow repo
      uses: actions/checkout@v3

    - name: Set up build environment
      run: |
        sudo apt update
        sudo apt install -y \
          build-essential \
          gcc g++ gcc-multilib g++-multilib \
          flex bison clang gawk gettext git \
          libncurses-dev libssl-dev python3-distutils \
          rsync unzip zlib1g-dev file libelf-dev libc6-dev \
          libtool autoconf automake cmake pkg-config libglib2.0-dev
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        echo "LD=ld" >> $GITHUB_ENV

    - name: Checkout OpenWrt buildroot
      uses: actions/checkout@v4
      with:
        repository: qosmio/openwrt-ipq
        path: openwrt
        fetch-depth: 0   # full history, keeps proper rXXXXX version

    - name: Apply custom config and files
      run: |
        cd openwrt/package

        # Clone custom packages
        git clone https://github.com/gSpotx2f/luci-app-interfaces-statistics.git
        git clone https://github.com/jerrykuku/luci-theme-argon.git
        git clone https://github.com/jerrykuku/luci-app-argon-config.git
        git clone https://github.com/gSpotx2f/luci-app-cpu-status.git

        cd ..

        ./scripts/feeds update -a
        ./scripts/feeds install -a

        # Add custom files if available
        if [ -d ../custom/files ]; then
          cp -a ../custom/files/. files/
          if [ -d files/etc/profile.d ]; then
            chmod -R +x files/etc/profile.d/
          fi
        fi

        # Apply patches if any
        if [ -d ../custom/patches ]; then
          for patch in ../custom/patches/*.patch; do
            [ -f "$patch" ] && patch -p1 < "$patch"
          done
        fi

        # Use the right config.seed for the current matrix device
        cp ../config.${{ matrix.device }}.seed .config

    - name: Build firmware
      run: |
        cd openwrt
        make defconfig
        make download -j$(nproc)
        make -j$(nproc)

    - name: Upload firmware to Cloudflare R2
      id: upload-firmware
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        R2_BUCKET: openwrt
        R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
      run: |
        cd openwrt/bin/targets
        TARGET_DIR=$(find . -type f -name version.buildinfo -exec dirname {} \;)
        cd "$TARGET_DIR"
        VERSION=$(cat version.buildinfo | tr -d '\n')
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "Uploaded version $VERSION for ${{ matrix.device }}"

        sync
        sha256sum -c sha256sums

        for file in openwrt-qualcommax-ipq807x-linksys_${{ matrix.device }}*; do
          if [[ -f "$file" ]]; then
            if [[ "$file" == *.manifest ]]; then
              newfile="manifest"
            else
              newfile="${file#openwrt-qualcommax-ipq807x-linksys_${{ matrix.device }}-}"
            fi
            mv "$file" "$newfile"
          fi
        done

        aws --endpoint-url "$R2_ENDPOINT" s3 cp . "s3://$R2_BUCKET/${{ matrix.device }}/$VERSION/" --recursive --exclude "packages/*"

    - name: Emit result JSON (always)
      if: always()
      env:
        R2_BUCKET: openwrt
        R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
        RUN_URL: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
      run: |
        DEVICE="${{ matrix.device }}"
        STATUS="${{ job.status }}"
        VERSION="${VERSION:-unknown}"

        # If success, link to R2; otherwise link to the run logs
        if [ "$STATUS" = "success" ] && [ "$VERSION" != "unknown" ]; then
          URL="https://${R2_BUCKET}.${R2_ENDPOINT#https://}/${DEVICE}/${VERSION}/"
        else
          URL="$RUN_URL"
        fi

        # Write JSON summary
        cat > result-${DEVICE}.json <<EOF
        {
          "device": "${DEVICE}",
          "status": "${STATUS}",
          "version": "${VERSION}",
          "url": "${URL}"
        }
        EOF

        ls -l result-${DEVICE}.json
        cat result-${DEVICE}.json

    - name: Upload result JSON artifact (always)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: result-${{ matrix.device }}
        path: result-${{ matrix.device }}.json
        if-no-files-found: error


  notify:
    runs-on: ubuntu-22.04
    needs: build
    if: always()
    steps:
      - name: Download result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          merge-multiple: true
          path: results

      - name: Build Discord message
        id: msg
        run: |
          set -e
          summary=""
          ok=true

          for f in results/result-*.json; do
            echo ">> Parsing $f"
            device=$(jq -r '.device' "$f")
            status=$(jq -r '.status' "$f")
            version=$(jq -r '.version' "$f")
            url=$(jq -r '.url' "$f")

            if [ "$status" = "success" ]; then
              summary="$summary\n✅ **$device** built successfully (version: $version)\n<$url>"
            else
              summary="$summary\n❌ **$device** failed to build → [View Logs]($url)"
              ok=false
            fi
          done

          if $ok; then
            title="# ✅ OpenWrt build succeeded!"
          else
            title="# ❌ OpenWrt build failed!"
          fi

          # Escape newlines for JSON
          content="$title\n$summary"
          content="${content//'%'/%25}"
          content="${content//$'\n'/%0A}"
          content="${content//$'\r'/%0D}"

          echo "content=$content" >> $GITHUB_OUTPUT

      - name: Send Discord message
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          CONTENT: ${{ steps.msg.outputs.content }}
        run: |
          curl -H "Content-Type: application/json" -X POST \
               -d "{\"content\": \"$CONTENT\"}" \
               "$DISCORD_WEBHOOK_URL"
